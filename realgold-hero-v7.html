<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RealGold â€” Hero Visualization (v7)</title>
  <style>
    :root{ --bg:#0a0a0a; --fg:#eaeaea; --gold:#c9a227; }
    html,body{height:100%}
    body{margin:0;background:var(--bg);font-family:ui-sans-serif,system-ui,-apple-system}
    #rg-root{position:fixed; inset:0; touch-action:none; cursor:grab}
    #rg-root.scrubbing{cursor:grabbing}
    canvas{display:block;width:100%;height:100%}
    .rg-fallback{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; color:#ccc; font-size:14px; text-align:center; padding:1rem}
    @media (prefers-reduced-motion: reduce){ .rg-anim{animation:none!important} }
  </style>
</head>
<body>
  <div id="rg-root" aria-label="Animated 3D layered cube with gold seams and internal orebody; drag horizontally to scrub the scan" role="img"></div>
  <noscript><div class="rg-fallback">Enable JavaScript to view the 3D visualization.</div></noscript>

  <script type="module">
    (async ()=>{
      let THREE;
      try { THREE = await import('three'); }
      catch{ THREE = await import('https://unpkg.com/three@0.160.0/build/three.module.js'); }

      let MarchingCubes = null;
      try { MarchingCubes = (await import('three/addons/objects/MarchingCubes.js')).MarchingCubes; }
      catch{ try { MarchingCubes = (await import('https://unpkg.com/three@0.160.0/examples/jsm/objects/MarchingCubes.js')).MarchingCubes; } catch{} }

      const container = document.getElementById('rg-root');
      const IS_MOBILE = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      const supportsWebGL = (() => { try{ const c=document.createElement('canvas'); return !!(c.getContext('webgl')||c.getContext('experimental-webgl')); }catch(e){ return false; } })();
      if(!supportsWebGL){ container.innerHTML='<div class="rg-fallback">Your device does not support WebGL.</div>'; return; }

      const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false, powerPreference: IS_MOBILE ? 'low-power' : 'high-performance' });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, IS_MOBILE?1.25:2));
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setClearColor('#0a0a0a', 1);
      renderer.localClippingEnabled = true;
      container.appendChild(renderer.domElement);

      const scene = new THREE.Scene();

      // Camera
      let camera;
      const ORTHO_SIZE = 3.6;
      function makeOrtho(){
        const aspect = container.clientWidth/container.clientHeight;
        const h=ORTHO_SIZE, w=ORTHO_SIZE*aspect;
        camera = new THREE.OrthographicCamera(-w, w, h, -h, 0.1, 100);
        camera.position.set(4,4,4);
        camera.lookAt(0,0,0);
      }
      makeOrtho();
      addEventListener('resize', ()=>{ renderer.setSize(container.clientWidth, container.clientHeight); makeOrtho(); });

      // Constants
      const SIZE=2.4, HALF=SIZE/2;
      const STRATA_COUNT = IS_MOBILE ? 24 : 48;
      const SCAN_H = 0.008*SIZE;
      const gridTop = IS_MOBILE ? 64 : 96;

      // Utils
      function lerp(a,b,t){return a+(b-a)*t}
      function clamp01(x){ return Math.max(0, Math.min(1, x)); }
      function fade(t){return t*t*t*(t*(t*6-15)+10)}
      function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}}
      function yFor(t){ return THREE.MathUtils.lerp(HALF-0.002-SCAN_H*0.5, -HALF+0.002+SCAN_H*0.5, t); }

      // Cube shell
      const cube = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(SIZE,SIZE,SIZE)), new THREE.LineBasicMaterial({ color:0xeaeaea, transparent:true, opacity:0.85 }));
      scene.add(cube);

      // Crown landmass
      const landGeo = new THREE.PlaneGeometry(SIZE*0.96, SIZE*0.96, gridTop, gridTop);
      const seed=777; const rand=mulberry32(seed);
      const grad=[]; for(let i=0;i<=gridTop;i++) grad[i]=Array(gridTop+1).fill(0).map(_=>({x:rand()*2-1,y:rand()*2-1}));
      function noise(x,y){ const xi=Math.floor(x), yi=Math.floor(y), xf=x-xi, yf=y-yi; function dot(ix,iy){ const g=grad[(iy%(gridTop+1)+gridTop+1)%(gridTop+1)][(ix%(gridTop+1)+gridTop+1)%(gridTop+1)]; return g.x*(x-ix)+g.y*(y-iy);} const u=fade(xf), v=fade(yf); const n00=dot(xi,yi), n10=dot(xi+1,yi), n01=dot(xi,yi+1), n11=dot(xi+1,yi+1); return lerp(lerp(n00,n10,u), lerp(n01,n11,u), v); }
      function fbm(x,y){ let val=0, amp=0.6, freq=1.0; for(let i=0;i<4;i++){ val+=amp*noise(x*freq,y*freq); amp*=0.5; freq*=2.02;} return val; }
      const lpos=landGeo.attributes.position;
      for(let i=0;i<lpos.count;i++){ const x=lpos.getX(i)/SIZE+10.5, y=lpos.getY(i)/SIZE+10.5; lpos.setZ(i, fbm(x,y)*0.48*HALF); }
      lpos.needsUpdate=true; landGeo.computeVertexNormals();
      const land = new THREE.LineSegments(new THREE.EdgesGeometry(landGeo), new THREE.LineBasicMaterial({ color:0xeaeaea, transparent:true, opacity:1 }));
      land.rotation.x=-Math.PI/2; land.position.y=HALF-0.001; scene.add(land);
      const topHeights=new Float32Array(lpos.count); for(let i=0;i<lpos.count;i++) topHeights[i]=lpos.getZ(i);

      // Strata
      const strataGroup=new THREE.Group(); scene.add(strataGroup);
      function makeStratum(i){ const t=i/(STRATA_COUNT-1); const g=new THREE.PlaneGeometry(SIZE*0.96,SIZE*0.96,gridTop,gridTop); const p=g.attributes.position; const blend=lerp(0.75,0.35,t), amp=lerp(0.20,0.10,t)*HALF, freq=1.0+t*1.6, off=t*3.14159; for(let j=0;j<p.count;j++){ const x=p.getX(j)/SIZE+10.5, y=p.getY(j)/SIZE+10.5; const base=topHeights[j]||0; const n=fbm((x+off)*freq,(y-off)*freq); const candidate=(blend*base + (1.0-blend)*(n*0.48*HALF)); p.setZ(j,(candidate/(0.48*HALF))*amp);} p.needsUpdate=true; g.computeVertexNormals(); const edges=new THREE.EdgesGeometry(g); const opacity=lerp(0.5,0.1,t); const mat=new THREE.LineBasicMaterial({ color:0xeaeaea, transparent:true, opacity}); const mesh=new THREE.LineSegments(edges,mat); mesh.rotation.x=-Math.PI/2; mesh.position.y=yFor(t); mesh.userData.layerIndex=i; return mesh; }
      for(let i=1;i<STRATA_COUNT;i++) strataGroup.add(makeStratum(i));

      // Gold seam particles (surface distributed)
      const goldGroup=new THREE.Group(); scene.add(goldGroup);
      function makeGoldPoints(i){ const t=i/(STRATA_COUNT-1); const y=yFor(t); const count=IS_MOBILE?50:100; const geo=new THREE.BufferGeometry(); const pos=new Float32Array(count*3); let n=0, tries=0; while(n<count && tries<count*10){ tries++; const x=(Math.random()-0.5)*SIZE*0.92; const z=(Math.random()-0.5)*SIZE*0.92; const sx=x/SIZE+10.5+t*3.14159; const sy=z/SIZE+10.5-t*3.14159; const freq=1.0+t*1.6; const v=fbm(sx*freq, sy*freq); if(v>0.36+t*0.1){ pos[n*3]=x; pos[n*3+1]=y+(Math.random()-0.5)*SCAN_H*0.6; pos[n*3+2]=z; n++; } } geo.setAttribute('position', new THREE.BufferAttribute(pos.subarray(0,n*3),3)); const mat=new THREE.PointsMaterial({ color:0xc9a227, size: IS_MOBILE ? 0.014 : 0.018, transparent:true, opacity:0.45, depthWrite:false, blending:THREE.AdditiveBlending}); const pts=new THREE.Points(geo,mat); pts.userData.layerIndex=i; return pts; }
      for(let i=0;i<STRATA_COUNT;i++) goldGroup.add(makeGoldPoints(i));

      // Slice & glow (with trailing slabs)
      const SCAN = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(SIZE*0.985, SCAN_H, SIZE*0.985)), new THREE.LineBasicMaterial({ color:0xc9a227 }));
      const GLOW = new THREE.Mesh(new THREE.BoxGeometry(SIZE*0.985, SCAN_H, SIZE*0.985), new THREE.MeshBasicMaterial({ color:0xc9a227, transparent:true, opacity:0.12, blending:THREE.AdditiveBlending }));
      const GLOW_T1 = GLOW.clone(); GLOW_T1.material = GLOW.material.clone(); GLOW_T1.material.opacity = 0.07; GLOW_T1.scale.y = 1.8;
      const GLOW_T2 = GLOW.clone(); GLOW_T2.material = GLOW.material.clone(); GLOW_T2.material.opacity = 0.04; GLOW_T2.scale.y = 3.0;
      scene.add(SCAN, GLOW, GLOW_T1, GLOW_T2);

      // Clip land above slice
      const plane=new THREE.Plane(new THREE.Vector3(0,-1,0), 0);
      const clipMat=new THREE.MeshBasicMaterial({ color:0xffffff, wireframe:true, clippingPlanes:[plane], transparent:true, opacity:0.18 });
      const clipLand=new THREE.Mesh(landGeo.clone(), clipMat); clipLand.rotation.x=-Math.PI/2; clipLand.position.y=HALF-0.001; scene.add(clipLand);

      // --- Orebody ---
      const useMC = !!MarchingCubes;
      let oreUniforms;

      if(useMC){
        const res = IS_MOBILE ? 24 : 36;
        oreUniforms = {
          uSliceY: { value: 0.0 },
          uSliceLagY: { value: 0.0 },
          uHighlightWidth: { value: 0.10 },
          uBaseColor: { value: new THREE.Color(0x4a3d12) },
          uHiColor: { value: new THREE.Color(0xc9a227) },
          uOpacity: { value: 0.22 }
        };
        const oreMat = new THREE.ShaderMaterial({
          uniforms: oreUniforms,
          transparent: true,
          blending: THREE.NormalBlending,
          vertexShader: `
            uniform float uSliceY;
            uniform float uSliceLagY;
            uniform float uHighlightWidth;
            varying float vH;
            varying vec3 vNormal;
            varying vec3 vWorld;
            void main(){
              vNormal = normalize(normalMatrix * normal);
              vec4 world = modelMatrix * vec4(position,1.0);
              vWorld = world.xyz;
              float d0 = abs(vWorld.y - uSliceY);
              float d1 = abs(vWorld.y - uSliceLagY);
              float d = min(d0, d1);
              vH = smoothstep(uHighlightWidth*1.4, 0.0, d);
              gl_Position = projectionMatrix * viewMatrix * world;
            }
          `,
          fragmentShader: `
            precision mediump float;
            varying float vH;
            varying vec3 vNormal;
            uniform vec3 uBaseColor;
            uniform vec3 uHiColor;
            uniform float uOpacity;
            void main(){
              vec3 L = normalize(vec3(0.5, 0.9, 0.3));
              float lambert = clamp(dot(normalize(vNormal), L), 0.0, 1.0);
              vec3 base = uBaseColor * (0.35 + 0.85*lambert);
              vec3 hi = mix(base, uHiColor, pow(vH, 0.55)) + vH*0.2;
              float a = uOpacity * (0.65 + 0.9*vH);
              gl_FragColor = vec4(hi, a);
            }
          `
        });

        const mc = new MarchingCubes(res, oreMat, true, true);
        mc.position.set(0,0,0);
        mc.scale.set(SIZE*0.96, SIZE*0.96, SIZE*0.96);
        mc.isolation = 55; // a bit lower to keep the thicker field continuous
        scene.add(mc);

        function buildOrebody(){
          mc.reset();
          const rng = mulberry32(424242);
          const nBalls = IS_MOBILE ? 26 : 34;
          const p0 = new THREE.Vector3(0.14, 0.20, 0.86);
          const p1 = new THREE.Vector3(0.86, 0.88, 0.14);
          const dir = new THREE.Vector3().subVectors(p1,p0);
          for(let i=0;i<nBalls;i++){
            const t = i/(nBalls-1);
            const pt = new THREE.Vector3().copy(p0).addScaledVector(dir, t);
            const wob = (Math.sin(t*8.0)+Math.sin(t*3.5+1.2))*0.010; // a touch more wobble
            pt.x += (rng()-0.5)*0.05 + wob;
            pt.y += (rng()-0.5)*0.03;
            pt.z += (rng()-0.5)*0.05 - wob;
            // 2x thickness vs v6
            const thickness = 2.0 * (0.045 + 0.06*Math.sin(t*Math.PI));
            mc.addBall(pt.x, pt.y, pt.z, thickness, 0.8);
            if(i % 5 === 0){
              const b = pt.clone().add(new THREE.Vector3((rng()-0.5)*0.14, (rng()-0.5)*0.06, (rng()-0.5)*0.14));
              mc.addBall(b.x, b.y, b.z, thickness*0.8, 0.8);
            }
          }
          // larger halos
          for(let j=0;j< (IS_MOBILE? 28:40); j++){
            const qx = 0.16 + rng()*0.68;
            const qy = 0.16 + rng()*0.68;
            const qz = 0.16 + rng()*0.68;
            mc.addBall(qx,qy,qz, 0.036, 0.9);
          }
          mc.update();
          mc.rotation.set(0.28, 0.0, -0.18);
        }
        buildOrebody();

        // store uniforms handle
      } else {
        // Fallback: denser, wider diagonal point-cloud orebody
        oreUniforms = { uSliceY:{value:0.0}, uSliceLagY:{value:0.0}, uW:{value:0.10} };
        const ORE_POINTS = IS_MOBILE ? 7000 : 12000;
        const rng = mulberry32(424242);
        const pos = new Float32Array(ORE_POINTS*3);
        const p0 = new THREE.Vector3(-HALF*0.65, -HALF*0.25, HALF*0.65);
        const p1 = new THREE.Vector3(HALF*0.65, HALF*0.65, -HALF*0.65);
        const dir = new THREE.Vector3().subVectors(p1,p0);
        for(let i=0;i<ORE_POINTS;i++){
          const t = (i/ORE_POINTS);
          const base = new THREE.Vector3().copy(p0).addScaledVector(dir, t + (rng()-0.5)*0.06);
          base.x += (rng()-0.5)*0.60;
          base.y += (rng()-0.5)*0.34;
          base.z += (rng()-0.5)*0.60;
          pos[i*3+0]=base.x; pos[i*3+1]=base.y; pos[i*3+2]=base.z;
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
        const mat = new THREE.ShaderMaterial({
          transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
          uniforms:{
            uSliceY: oreUniforms.uSliceY,
            uSliceLagY: oreUniforms.uSliceLagY,
            uW: oreUniforms.uW,
            uBase: { value: new THREE.Color(0x4a3d12) },
            uGold: { value: new THREE.Color(0xc9a227) },
            uSize: { value: IS_MOBILE? 2.0 : 2.8 }
          },
          vertexShader:`
            uniform float uSliceY; uniform float uSliceLagY; uniform float uW; uniform float uSize;
            varying float vH;
            void main(){
              vec4 world = modelMatrix * vec4(position,1.0);
              float d0 = abs(world.y - uSliceY);
              float d1 = abs(world.y - uSliceLagY);
              float d = min(d0,d1);
              vH = smoothstep(uW*1.2, 0.0, d);
              gl_Position = projectionMatrix * viewMatrix * world;
              gl_PointSize = uSize * (1.0 + 1.6*vH);
            }
          `,
          fragmentShader:`
            precision mediump float;
            varying float vH;
            uniform vec3 uBase; uniform vec3 uGold;
            void main(){
              vec2 uv = gl_PointCoord - 0.5;
              float r = length(uv);
              if(r>0.5) discard;
              float core = smoothstep(0.5, 0.0, r);
              vec3 col = mix(uBase, uGold, vH);
              float a = core * (0.10 + 0.90*vH);
              gl_FragColor = vec4(col, a);
            }
          `
        });
        const pts = new THREE.Points(geo, mat);
        scene.add(pts);
      }

      // Sparkle points near slice
      const sparkleGeo = new THREE.BufferGeometry();
      const SPARK = IS_MOBILE ? 1200 : 2000;
      const spos = new Float32Array(SPARK*3);
      for(let i=0;i<SPARK;i++){
        spos[i*3 + 0] = (Math.random()-0.5)*SIZE*0.86;
        spos[i*3 + 1] = (Math.random()-0.5)*SIZE*0.86;
        spos[i*3 + 2] = (Math.random()-0.5)*SIZE*0.86;
      }
      sparkleGeo.setAttribute('position', new THREE.BufferAttribute(spos,3));
      const sparkleMat = new THREE.ShaderMaterial({
        transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
        uniforms:{
          uSliceY: { value: 0.0 },
          uSliceLagY: { value: 0.0 },
          uW: { value: 0.10 },
          uSize: { value: IS_MOBILE? 1.6 : 2.0 },
          uBase: { value: new THREE.Color(0x5a4a12) },
          uGold: { value: new THREE.Color(0xc9a227) }
        },
        vertexShader:`
          uniform float uSliceY; uniform float uSliceLagY; uniform float uW; uniform float uSize;
          varying float vH;
          void main(){
            vec4 world = modelMatrix * vec4(position,1.0);
            float d0 = abs(world.y - uSliceY);
            float d1 = abs(world.y - uSliceLagY);
            float d = min(d0,d1);
            vH = smoothstep(uW*1.2, 0.0, d);
            gl_Position = projectionMatrix * viewMatrix * world;
            gl_PointSize = uSize * (1.0 + 1.4*vH);
          }
        `,
        fragmentShader:`
          precision mediump float;
          varying float vH;
          uniform vec3 uBase; uniform vec3 uGold;
          void main(){
            vec2 uv = gl_PointCoord - 0.5;
            float r = length(uv);
            if(r>0.5) discard;
            float core = smoothstep(0.5, 0.0, r);
            vec3 col = mix(uBase, uGold, vH);
            float a = core * (0.05 + 0.95*vH);
            gl_FragColor = vec4(col, a);
          }
        `
      });
      const spark = new THREE.Points(sparkleGeo, sparkleMat);
      scene.add(spark);

      // Animation state
      let tAcc=0, dir=1;
      const SPEED = IS_MOBILE ? 0.144 : 0.192; // slowed 20%
      const clock=new THREE.Clock();
      let userInteracting=false;
      const RESUME_DELAY = 550;
      let resumeTimer=null;

      function setSliceFromX(clientX){
        const r = renderer.domElement.getBoundingClientRect();
        const nx = (clientX - r.left) / r.width;
        tAcc = clamp01(nx);
      }
      function beginScrub(x){
        userInteracting=true;
        container.classList.add('scrubbing');
        clearTimeout(resumeTimer);
        setSliceFromX(x);
      }
      function moveScrub(x){ if(userInteracting) setSliceFromX(x); }
      function endScrub(){
        if(!userInteracting) return;
        userInteracting=false;
        container.classList.remove('scrubbing');
        clearTimeout(resumeTimer);
        resumeTimer = setTimeout(()=>{}, RESUME_DELAY);
      }

      renderer.domElement.addEventListener('pointerdown', (e)=>{ renderer.domElement.setPointerCapture(e.pointerId); beginScrub(e.clientX); e.preventDefault(); }, {passive:false});
      renderer.domElement.addEventListener('pointermove', (e)=>{ moveScrub(e.clientX); }, {passive:true});
      renderer.domElement.addEventListener('pointerup', (e)=>{ endScrub(); }, {passive:true});
      renderer.domElement.addEventListener('pointercancel', (e)=>{ endScrub(); }, {passive:true});
      renderer.domElement.addEventListener('pointerleave', (e)=>{ endScrub(); }, {passive:true});

      // Visibility
      let visible=true;
      const io=new IntersectionObserver(entries=>{ visible=entries[0]?.isIntersecting ?? true; }, {threshold:0.1});
      io.observe(container);

      // trailing y positions for long decay
      let yLag1 = 0.0, yLag2 = 0.0;

      function renderFrame(){
        const dt=clock.getDelta();
        if(!userInteracting){
          tAcc += dir * SPEED * dt;
          if(tAcc>1){ tAcc=1; dir=-1; } else if(tAcc<0){ tAcc=0; dir=1; }
        }
        const y=yFor(tAcc);
        const k1 = 4.0, k2 = 2.0;
        yLag1 += (y - yLag1) * k1 * dt;
        yLag2 += (y - yLag2) * k2 * dt;

        SCAN.position.y = y;
        GLOW.position.y = y;
        GLOW_T1.position.y = yLag1;
        GLOW_T2.position.y = yLag2;

        plane.constant = HALF - y;

        // highlights
        if(oreUniforms){
          if(oreUniforms.uSliceY) oreUniforms.uSliceY.value = y;
          if(oreUniforms.uSliceLagY) oreUniforms.uSliceLagY.value = yLag1;
        }
        sparkleMat.uniforms.uSliceY.value = y;
        sparkleMat.uniforms.uSliceLagY.value = yLag1;

        const et=clock.elapsedTime;
        land.rotation.z = Math.sin(et*0.08)*0.002;
        strataGroup.rotation.z = Math.sin(et*0.06)*0.0015;
        const pulse = (Math.sin(et*3)+1)*0.5;
        GLOW.material.opacity = 0.10 + 0.06*pulse;

        const idxFloat=tAcc*(STRATA_COUNT-1), falloff=6;
        strataGroup.children.forEach(child=>{ const d=Math.abs((child.userData.layerIndex||0)-idxFloat); const near=Math.max(0,1-d/falloff); child.material.opacity=THREE.MathUtils.lerp(0.05,0.6,near); child.material.color.setHex(d<0.5?0xffffff:0xeaeaea); });
        goldGroup.children.forEach(pts=>{ const d=Math.abs((pts.userData.layerIndex||0)-idxFloat); const near=Math.max(0,1-d/falloff); pts.material.opacity=THREE.MathUtils.lerp(0.18,0.9,near); });

        renderer.render(scene, camera);
      }

      if (renderer.setAnimationLoop) renderer.setAnimationLoop(()=>{ if(!visible) return; renderFrame(); });
      else (function loop(){ if(visible) renderFrame(); requestAnimationFrame(loop); })();

      renderer.domElement.addEventListener('webglcontextlost', (e)=>{ e.preventDefault(); setTimeout(()=>location.reload(), 150); }, false);
    })();
  </script>
</body>
</html>
